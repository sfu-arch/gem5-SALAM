# TapeFlow #
TapeFlow is a high-performance Automatic Differentiation tool that extends the Enzyme compiler. It manages tape accesses explicitly using a scratchpad and generates a LLVM Intermediate Representation (IR). It then runs the IR on a hardware with exposed scratchpad interface. This hardware is modeled by gem5-Salam.

# Features

- Efficient and high-performance Automatic Differentiation.
- Seamless integration with the Enzyme compiler.
- Automatic memory orchestration.
- Scratchpad simulation is done by gem5-SALAM.

# Requirements
- LLVM-12 or newer. Must be installed from source.
- gem5 dependencies

# TapeFlow Setup
First, clone this repository:
```
git clone --recursive https://github.com/sfu-arch/TapeFlow.git
```
## Building the compiler
To build our comiler:
```bash
cd TapeFlowCompiler/enzyme
mkdir build && cd build
cmake -G Ninja .. -DLLVM_DIR=/path/to/llvm/lib/cmake/llvm -DLLVM_EXTERNAL_LIT=/path/to/lit/lit.py
ninja
```
Make sure the build is complete and `LLVMEnzyme-*.so` is generated in the `build/Enzyme/` directory.

## Building simulator
We use our modified version a gem5-SALAM to execute the code generated by our compiler.

### All Required Dependencies for gem5-SALAM (Ubuntu 20.04)

```bash
sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \
    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \
    python3-dev python-is-python3 libboost-all-dev pkg-config
```

After installing these specific libraries, simply run the [update alternatives](https://github.com/TeCSAR-UNCC/gem5-SALAM/blob/main/docs/update-alternatives.sh) script in docs/.

### building gem5
Below is the bash command you would use to build the opt binary. 

```bash
scons build/ARM/gem5.opt -j`nproc`
```

For more information regarding the binary types, and other build information refer to the gem5 build documentation [here](http://learning.gem5.org/book/part1/building.html).

Congrats! You can now run TapeFlow.

# Using TapeFlow
The following graph illustrates the TapeFlow's toolflow:
```mermaid
flowchart TD

A[source code\norig.cpp] -->|clang++ -S -emit-llvm orig.cpp| B[LLVM IR\norig.ll]
B --> |opt orig.ll -enzyme -S\n-enable-tf -spad-size=N| C[LLVM-IR\noptimized gradient function]
C -->|gem5-SALAM LLVMInterface| E
F[Hardware Specification] -->|gem5-SALAM system builder| E[Execute gradient function on CGRA] --> G[Runtime Results]
```
First, we compile the source code using our compiler and then feed the resulting IR to the hardware modeled by gem5-SALAM.

The AD examples under **benchmarks/AD** are good examples for you to get started with TapeFlow.
In order to use these benchmarks, it is required to have the ARM GCC cross-compiler installed. If you didn't already install it when you setup the dependencies, you can install it in Ubuntu by running the below command:

```bash
sudo apt-get install gcc-arm-none-eabi
```

**tf.sh** requires an environment variable named **M5_PATH** to be set. You will want to point it to your TapeFlow path as shown below. 

```bash
export M5_PATH=/path/to/TapeFlow
```

The `tf.sh` script validates the benchmark, compiles it, introduces the ir path to gem5-SALAM, and runs the simulation. 
It runs the benchmark with and without TapeFlow's optimizations and stores the results in `results.csv`. This file contains runtime details including cache misses, execution cycles, total DRAM accesses, etc.
```bash
./tf.sh -b [benchmark]
```

You can run the benchmark with different cache sizes and SPAD size. Use
```
./tf.sh -h
```
to learn how to set them.
## How to use the compiler alone?
If you want to write a program, compile it using TapeFlow's compiler, and see the resulting IR, you can do the following steps:
- Write your function in C/C++ and use Enzyme to differentiate it. You can use the existing functions in the `Benchmarks/AD/[benchmark]/hw/[benchmark].c` or check out Enzyme tutorial.
- Compile the program using clang:
```bash
clang++ -S -emit-llvm test.cpp
```
- Use the following command to generate IR with TapeFlow:

```bash
opt test.ll -load=path/to/LLVMEnzyme-*.so -enzyme -enable-tf -spad-size=512 -o output.ll
```
`output.ll` would contain the the gradient function generated by Enzyme and TapeFlow's instrumentation.

## How to write a new test program and run it using gem5-SALAM?
The easiest way is to copy the existing `benchmarks/AD/template` folder and rename it to the name of your custom benchmark. Then, modify the files listed below:
- In `config.yml`:
    - Modify the paths to match the path of the benchmark.
- In `/hw/acc.c`:
    - write down the function you want to differentiate. You can use `malloc` to allocate on heap.
    - Use Enzyme to differentiate the function.
    - This file must contain a `top` function that directly or inderectly calls your gradient function.
- Run the new benchmark using the `tf.sh`:
```bash
./tf.sh -b $benchmark
```

Note that the `benchmarks/AD/[benchmark]/*_clstr_hw_defines.h` and `configs/SALAM/generated/[benchmark].py` will be overwritten each time you run `./tf.sh` because it is running `systembuilder.py`. 

# FAQ
Some bugs might appear during the compile time or runtime. We mention some of them and how to resolve them.
## Error 1:
```bash
build/ARM/hwacc/llvm_interface.cc:1522: panic: No function marked as top-level. Set the top_name parameter for your LLVMInterface to the name of the top-level function
```
### Solution:
gem5-Salam can not find the top function because it is not declared in the source file or has been renamed by the compiler. You can verify this by looking at the `.ll` files created in the `hw` directory. If you have multiple `.c` files, you have to declare the top in all of them. To solve this issue, add the following lines in all of the `.c` files in the `hw` directory. This prevents the compiler to rename this function.

```C
extern "C" {
    void top();
}
```

